### **Item 4: Know how to view deduced types.**

IDE Editors
Code needs to be mostly compilable

Compiler Diagnostics
Cheat with compiler, create an undefined class template, like:

template<typename T>
class TD;

and then try to instantiate to get an error message:
	
	TD<dectype(x)> xType;
	TD<dectype(y)> yType;

using *variableNameType*, and in log will see error giving type (ex):

	error: aggregate 'TD xType' has incomplete type and cannot be defined

Runtime Output

Boost.TypeIndex, useful to get accurate type information:

	#include <boost/type_index.hpp>
	
	
	template<typename T>
	void f(const T& param)
	{
		using std::cout;
		using boost::typeindex::type_id_with_cvr;
	
		//show T
		cout << "T= " << type_id_with_cvr<T>().pretty_name() << '\n';
	
		// show param's type
		cout << "param= " << type_id_with_cvr<decltype(param)>().pretty_name() << '\n';
	...
	}

## **Chapter 2: auto**

### **Item 5: Prefer auto to explicit type declarations.**

closures - and unnamed function object generated by a lambda expression  

auto variables must be initialized:

	int x1; // potentially uninitialized
	auto x2; // error! initializer required
	auto x3 = 0; // fine, x's value is well defined

std::function is a template in the C++11 Standard Library that generalizes the idea of a function pointer, can refer to any callable object

In the competition between auto and std::function for holding a closure, auto wins

Auto away unintentional type mismatches:

	std::unordered_map<std::string, int> m;
	
	for (const auto& p : m) {
	â€¦ // as before 
	}

Explicitly specifying type can lead to implicit conversions that you neither wanted nor expected

Things to remember:
-Auto variables must be initialized, generally immune to type mismatches that can lead to problems
-Auto type variables are subject to pitfalls

### **Item 6: Use the explicitly typed initializer idiom when auto deduces undesired types.**

As a general rule "invisible" proxy classes don't play well with auto. 

want to avoid code of the form: 

	auto someVar = expression of "invisible" proxy class type;

How do you find them (invisible proxy classes)?
-Look for unconventional return type such as:
	reference operator[](size_type n);

Solution is to force a different type deduction, called the explicitly type initializer idiom, involves declaring a variable with auto, but casting the initializing expression to the type you want auto to deduce:

	auto highPriority = static_cast<bool>(features(w)[5]);

for matrix example:

	auto sum = static_cast<Matrix>(m1 + m2 + m3 + m4);

Can also use to deliberately create a variable of a type that is different from that generated by the initializing expression:

	double calcEpsilon(); // return tolerance value
	float ep = calcEpsilon(); // implicitly convert double -> float
	auto ep = static_cast<float>(calcEpsilon()); 

Things to remember:
-'Invisible' proxy types can cause issues when using auto by deducing the 'wrong' type for an initializing expression
-The explicitly typed initializer idiom forces auto to deduce the type you want it to have

